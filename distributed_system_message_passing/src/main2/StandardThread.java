package main2;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.concurrent.ArrayBlockingQueue;

public class StandardThread extends Thread{

    // reference to the message sequencer
    private File file;
    private FileWriter writer;
    private int numM;
    private int messagecounter;
    // inbox queue
    public ArrayBlockingQueue<Message> inbox;
    private ArrayList<Message> messages;
    private ArrayList<StandardThread> threads;
    private int maxcounter;
    
    /**
     * Create thread with a bounded inbox queue
     *
     * @param numM number of messages generated by the message generator
     */
    public StandardThread(int numM) {
        this.inbox = new ArrayBlockingQueue<>(numM*2);
        this.file = new File("Logfiles/"+this.getName()+"_logfile.txt");
        try {
			this.writer = new FileWriter(file);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
       /* try {
			this.writer.write(this.getName() + " Logfile\n");
			//this.writer.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}*/
        this.numM = numM;
        this.messagecounter = 0;
        this.messages = new ArrayList<>();
        this.maxcounter=0;
    }
    
    public void setThreads(ArrayList<StandardThread> threads) {
    	this.threads=threads;
    }


    @Override
    public void run() {
    	Message msg;
    	while(this.messagecounter != numM) {
    		msg = this.inbox.poll();
    		if(msg != null) {
    			//if generator sent the msg
	    		if(msg.external()){
	    			msg.switchMessageType();
	    			//External msg ist zum Zeitpunkt maxcounter+1 angekommen.
	    			this.maxcounter++;
	    			msg.setLamportstamp(this.maxcounter);
	    			
	    			//nachricht an alle Threads schicken
	    			for(int j=0;j<threads.size(); j++) {
	    				try {
							threads.get(j).inbox.put(msg);
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						};
	    			}
	    			
	    		}else {//thread sent the msg
	    			if(msg.getLamportstamp()>this.maxcounter) {
	    				this.maxcounter=msg.getLamportstamp();
	    			}
	    			//Es ist eine interne Nachricht angekommen counter um eins erh√∂hen
	    			this.messagecounter++;
	    			
	    			messages.add(msg);
	    		}

    		}

    	}
    	
    	//write in log...

    	/****SORTIERUNG****/
    	messages.sort(new MessageComparator());
    	
    	for(int i = 0; i<messages.size();i++) {
    		msg = messages.get(i);
    		try {
				this.writer.write(Integer.toString(msg.getPayload()) + " ("+Integer.toString(msg.getLamportstamp())+","+Integer.toString(msg.getRcptthread())+")\n");
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
    	}
    	
    	try {
			this.writer.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
    }
}

